{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/AffiliateVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./Multisig.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title AffiliateVault\n * @dev Handles USDT deposits and controlled payments with limited daily allowance\n */\ncontract AffiliateVault is Multisig {\n    address public SUPER_ADMIN;\n    IERC20 public usdtToken;\n    uint256 public PRICE = 1 * 1e18;\n    uint256 public DAILY_LIMIT = 5000 * 1e18;\n    uint256 public dailySpent;\n    uint256 public lastResetTimestamp;\n\n    event Deposited(address indexed from, uint256 amount, uint256 timestamp);\n    event Paid(address indexed to, uint256 amount, uint256 timestamp);\n\n    constructor(address[] memory _owners, uint256 _numConfirmationsRequired, address _usdtTokenAddress)\n        Multisig(_owners, _numConfirmationsRequired)\n    {\n        SUPER_ADMIN = _owners[0];\n        usdtToken = IERC20(_usdtTokenAddress);\n    }\n\n    modifier isSuperAdmin() {\n        require(msg.sender == SUPER_ADMIN, \"Only Super Admin\");\n        _;\n    }\n\n    function deposit(uint256 amount) external {\n        require(amount >= PRICE, \"Amount below minimum\");\n        require(usdtToken.allowance(msg.sender, address(this)) >= amount, \"Not approved\");\n        require(usdtToken.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n        emit Deposited(msg.sender, amount, block.timestamp);\n    }\n\n    function payUser(address recipient, uint256 amount) external isSuperAdmin {\n        _enforceDailyLimit(amount);\n        require(usdtToken.balanceOf(address(this)) >= amount, \"Insufficient balance\");\n        require(usdtToken.transfer(recipient, amount), \"Transfer failed\");\n        emit Paid(recipient, amount, block.timestamp);\n    }\n\n    function _enforceDailyLimit(uint256 amount) internal {\n        if (block.timestamp > lastResetTimestamp + 1 days) {\n            dailySpent = 0;\n            lastResetTimestamp = block.timestamp;\n        }\n        require(dailySpent + amount <= DAILY_LIMIT, \"Daily payout limit exceeded\");\n        dailySpent += amount;\n    }\n\n    function getContractBalance() external view returns (uint256) {\n        return usdtToken.balanceOf(address(this));\n    }\n\n    function getRemainingDailyQuota() external view returns (uint256) {\n        if (block.timestamp > lastResetTimestamp + 1 days) {\n            return DAILY_LIMIT;\n        }\n        return DAILY_LIMIT - dailySpent;\n    }\n\n    function setMinPrice(uint256 newPrice) external onlyAdmin {\n        require(newPrice >= 1e18, \"Minimum must be >= 1 USDT\");\n        PRICE = newPrice;\n    }\n\n    function setDailyLimit(uint256 newLimit) external onlyAdmin {\n        require(newLimit > 0, \"Invalid limit\");\n        DAILY_LIMIT = newLimit;\n    }\n}\n"
    },
    "contracts/Multisig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Multisig\n * @dev Base multisig contract for shared approval logic\n */\ncontract Multisig {\n    address[] public owners;\n    mapping(address => bool) public isOwner;\n    uint public numConfirmationsRequired;\n\n    struct Transaction {\n        address to;\n        uint value;\n        bool executed;\n        uint numConfirmations;\n        uint timestamp;\n        string reason;\n    }\n\n    Transaction[] public transactions;\n    mapping(uint => mapping(address => bool)) public isConfirmed;\n\n    modifier onlyAdmin() {\n        require(isOwner[msg.sender], \"not owner\");\n        _;\n    }\n\n    modifier txExists(uint _txIndex) {\n        require(_txIndex < transactions.length, \"tx does not exist\");\n        _;\n    }\n\n    modifier notExecuted(uint _txIndex) {\n        require(!transactions[_txIndex].executed, \"tx already executed\");\n        _;\n    }\n\n    modifier notConfirmed(uint _txIndex) {\n        require(!isConfirmed[_txIndex][msg.sender], \"tx already confirmed\");\n        _;\n    }\n\n    event SubmitTransaction(address indexed owner, uint indexed txIndex, address indexed to, uint value, string reason);\n    event ConfirmTransaction(address indexed owner, uint indexed txIndex);\n    event RevokeConfirmation(address indexed owner, uint indexed txIndex);\n    event ExecuteTransaction(address indexed owner, uint indexed txIndex);\n\n    constructor(address[] memory _owners, uint _numConfirmationsRequired) {\n        require(_owners.length > 0, \"owners required\");\n        require(_numConfirmationsRequired > 0 && _numConfirmationsRequired <= _owners.length, \"invalid number of required confirmations\");\n\n        for (uint i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n            require(owner != address(0), \"invalid owner\");\n            require(!isOwner[owner], \"owner not unique\");\n            isOwner[owner] = true;\n            owners.push(owner);\n        }\n        numConfirmationsRequired = _numConfirmationsRequired;\n    }\n\n    function submitTransaction(address _to, uint _value, string memory _reason) public onlyAdmin {\n        uint txIndex = transactions.length;\n        transactions.push(Transaction({\n            to: _to,\n            value: _value,\n            executed: false,\n            numConfirmations: 0,\n            timestamp: block.timestamp,\n            reason: _reason\n        }));\n        emit SubmitTransaction(msg.sender, txIndex, _to, _value, _reason);\n    }\n\n    function confirmTransaction(uint _txIndex) public onlyAdmin txExists(_txIndex) notExecuted(_txIndex) notConfirmed(_txIndex) {\n        Transaction storage transaction = transactions[_txIndex];\n        transaction.numConfirmations += 1;\n        isConfirmed[_txIndex][msg.sender] = true;\n        emit ConfirmTransaction(msg.sender, _txIndex);\n    }\n\n    function executeTransaction(uint _txIndex) public onlyAdmin txExists(_txIndex) notExecuted(_txIndex) {\n        Transaction storage transaction = transactions[_txIndex];\n        require(transaction.numConfirmations >= numConfirmationsRequired, \"cannot execute tx\");\n        transaction.executed = true;\n        (bool success, ) = transaction.to.call{value: transaction.value}(\"\");\n        require(success, \"tx failed\");\n        emit ExecuteTransaction(msg.sender, _txIndex);\n    }\n\n    function revokeConfirmation(uint _txIndex) public onlyAdmin txExists(_txIndex) notExecuted(_txIndex) {\n        require(isConfirmed[_txIndex][msg.sender], \"tx not confirmed\");\n        Transaction storage transaction = transactions[_txIndex];\n        transaction.numConfirmations -= 1;\n        isConfirmed[_txIndex][msg.sender] = false;\n        emit RevokeConfirmation(msg.sender, _txIndex);\n    }\n\n    function getOwners() public view returns (address[] memory) {\n        return owners;\n    }\n\n    function getTransaction(uint _txIndex) public view returns (address, uint, bool, uint, uint, string memory) {\n        Transaction storage txData = transactions[_txIndex];\n        return (txData.to, txData.value, txData.executed, txData.numConfirmations, txData.timestamp, txData.reason);\n    }\n\n    function getTransactionCount() public view returns (uint) {\n        return transactions.length;\n    }\n}\n\n\n// contract Multisig {\n\n//     // Constructor\n//     constructor(address[] memory _owners, uint _numConfirmationsRequired) {\n//         require(_owners.length > 0, \"owners required\");\n//         require(\n//             _numConfirmationsRequired > 0 &&\n//                 _numConfirmationsRequired <= _owners.length,\n//             \"invalid number of required confirmations\"\n//         );\n\n//         for (uint i = 0; i < _owners.length; i++) {\n//             address owner = _owners[i];\n\n//             require(owner != address(0), \"invalid owner\");\n//             require(!isOwner[owner], \"owner not unique\");\n\n//             isOwner[owner] = true;\n//             owners.push(owner);\n//         }\n\n//         numConfirmationsRequired = _numConfirmationsRequired;\n        \n//     }\n\n\n//     event SubmitTransaction(\n//         address indexed owner,\n//         uint indexed txIndex,\n//         address indexed to,\n//         uint value\n//     );\n//     event ConfirmTransaction(address indexed owner, uint indexed txIndex);\n//     event RevokeConfirmation(address indexed owner, uint indexed txIndex);\n//     event ExecuteTransaction(address indexed owner, uint indexed txIndex);\n\n//     address[] public owners;\n//     mapping(address => bool) public isOwner;\n//     uint public numConfirmationsRequired;\n\n\n//     struct Transaction {\n//         address to;\n//         uint value;\n//         bool executed;\n//         uint numConfirmations;\n//     }\n\n//     // mapping from tx index => owner => bool\n//     mapping(uint => mapping(address => bool)) public isConfirmed;\n\n//     Transaction[] public transactions;\n\n//     modifier onlyAdmin() {\n//         require(isOwner[msg.sender], \"not owner\");\n//         _;\n//     }\n\n//     modifier txExists(uint _txIndex) {\n//         require(_txIndex < transactions.length, \"tx does not exist\");\n//         _;\n//     }\n\n//     modifier notExecuted(uint _txIndex) {\n//         require(!transactions[_txIndex].executed, \"tx already executed\");\n//         _;\n//     }\n\n//     modifier notConfirmed(uint _txIndex) {\n//         require(!isConfirmed[_txIndex][msg.sender], \"tx already confirmed\");\n//         _;\n//     }\n\n//     event Init(uint256, uint256);\n\n\n//     //1.Generar solicitud de retiro\n//     function submitTransaction(address _to,uint _value) public onlyAdmin {\n\n//         uint txIndex = transactions.length;\n\n//         uint256 totalAmount=address(this).balance;\n//         require(totalAmount>=_value,'incorrect value');\n\n//         transactions.push(\n//             Transaction({\n//                 to: _to,\n//                 value: _value,\n//                 executed: false,\n//                 numConfirmations: 0\n//             })\n//         );\n\n//         emit SubmitTransaction(msg.sender, txIndex, _to, _value);\n//     }\n\n\n//     // Los socios llaman a la funcion para dar permiso a retirar los fondos\n//     function confirmTransaction(uint _txIndex)public onlyAdmin\n//         txExists(_txIndex)\n//         notExecuted(_txIndex)\n//         notConfirmed(_txIndex){\n\n//         Transaction storage transaction = transactions[_txIndex];\n//         transaction.numConfirmations += 1;\n//         isConfirmed[_txIndex][msg.sender] = true;\n\n//         emit ConfirmTransaction(msg.sender, _txIndex);\n//     }\n\n//     // Si se tienen las confirmaciones necesarias, ejecutar transaccion\n//     function executeTransaction(uint _txIndex)\n//         public\n//         onlyAdmin\n//         txExists(_txIndex)\n//         notExecuted(_txIndex){\n\n//         Transaction storage transaction = transactions[_txIndex];\n\n//         require(\n//             transaction.numConfirmations >= numConfirmationsRequired,\n//             \"cannot execute tx\"\n//         );\n\n//         transaction.executed = true;\n        \n//         // Retiro del servidor los fondos\n//         (bool success, ) = transaction.to.call{value: transaction.value}(\"\");\n\n//         require(success, \"tx failed\");\n\n//         emit ExecuteTransaction(msg.sender, _txIndex);\n//     }\n\n//     // Socio retira su permiso de la transaccion\n//     function revokeConfirmation(uint _txIndex)\n//         public\n//         onlyAdmin\n//         txExists(_txIndex)\n//         notExecuted(_txIndex){\n//         Transaction storage transaction = transactions[_txIndex];\n\n//         require(isConfirmed[_txIndex][msg.sender], \"tx not confirmed\");\n\n//         transaction.numConfirmations -= 1;\n//         isConfirmed[_txIndex][msg.sender] = false;\n\n//         emit RevokeConfirmation(msg.sender, _txIndex);\n//     }\n\n//     // Returns owners of the contract \n//     function getOwners() public view returns (address[] memory) {\n//         return owners;\n//     }\n\n//     function getTransactionCount() public view returns (uint) {\n//         return transactions.length;\n//     }\n\n//     function getIsConfirmed(uint _txIndex) public view returns (bool) {\n//         return isConfirmed[_txIndex][msg.sender];\n//     }\n\n//     function getTransaction(uint _txIndex)public view\n//         returns (\n//             address to,\n//             uint value,\n//             bool executed,\n//             uint numConfirmations\n//         ){\n//         Transaction storage transaction = transactions[_txIndex];\n\n//         return (\n//             transaction.to,\n//             transaction.value,\n//             transaction.executed,\n//             transaction.numConfirmations\n//         );\n//     }\n\n// }"
    },
    "contracts/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AffiliateVault.sol\";\n\ncontract VaultFactory {\n    address public server;\n    address public arbiter;\n    address public usdtToken;\n    mapping(address => address) public affiliateVaults;\n    address[] public allVaults;\n\n    event VaultCreated(address indexed affiliate, address vault);\n\n    constructor(address _server, address _arbiter, address _usdtToken) {\n        server = _server;\n        arbiter = _arbiter;\n        usdtToken = _usdtToken;\n    }\n\n\n\n    function createVault() external {\n        require(affiliateVaults[msg.sender] == address(0), \"Vault already exists\");\n\n        address [] memory owners = new address[](3);\n        owners[0] = server; \n        owners[1] = arbiter;\n        owners[2] = msg.sender; // affiliate (caller)\n\n        AffiliateVault vault = new AffiliateVault(\n            owners,\n            2, // multisig: 2 out of 3\n            usdtToken\n        );\n\n        affiliateVaults[msg.sender] = address(vault);\n        allVaults.push(address(vault));\n\n        emit VaultCreated(msg.sender, address(vault));\n    }\n\n\n    function createVaultFor(address affiliate) external {\n        require(msg.sender == server, \"Only server can deploy\");\n        require(affiliateVaults[affiliate] == address(0), \"Vault already exists\");\n\n        address[] memory owners = new address[](3);\n        owners[0] = server;\n        owners[1] = arbiter;\n        owners[2] = affiliate;\n\n        AffiliateVault vault = new AffiliateVault(owners, 2, usdtToken);\n\n        affiliateVaults[affiliate] = address(vault);\n        allVaults.push(address(vault));\n        emit VaultCreated(affiliate, address(vault));\n    }\n\n    function getVault(address affiliate) external view returns (address) {\n        return affiliateVaults[affiliate];\n    }\n\n    function getAllVaults() external view returns (address[] memory) {\n        return allVaults;\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}