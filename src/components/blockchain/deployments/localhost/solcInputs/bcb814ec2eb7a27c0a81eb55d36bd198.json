{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/AffiliateVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./Multisig.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title AffiliateVault\n * @dev Handles USDT deposits and controlled payments with limited daily allowance\n */\ncontract AffiliateVault is Multisig {\n    address public SUPER_ADMIN;\n    IERC20 public usdtToken;\n    uint256 public PRICE = 1 * 1e18;\n    uint256 public DAILY_LIMIT = 5000 * 1e18;\n    uint256 public dailySpent;\n    uint256 public lastResetTimestamp;\n\n    event Deposited(address indexed from, uint256 amount, uint256 timestamp);\n    event Paid(address indexed to, uint256 amount, uint256 timestamp);\n\n    constructor(address[] memory _owners, uint256 _numConfirmationsRequired, address _usdtTokenAddress)\n        Multisig(_owners, _numConfirmationsRequired)\n    {\n        SUPER_ADMIN = _owners[0];\n        usdtToken = IERC20(_usdtTokenAddress);\n    }\n\n    modifier isSuperAdmin() {\n        require(msg.sender == SUPER_ADMIN, \"Only Super Admin\");\n        _;\n    }\n\n    function deposit(uint256 amount) external {\n        require(amount >= PRICE, \"Amount below minimum\");\n        require(usdtToken.allowance(msg.sender, address(this)) >= amount, \"Not approved\");\n        require(usdtToken.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n        emit Deposited(msg.sender, amount, block.timestamp);\n    }\n\n    function payUser(address recipient, uint256 amount) external isSuperAdmin {\n        _enforceDailyLimit(amount);\n        require(usdtToken.balanceOf(address(this)) >= amount, \"Insufficient balance\");\n        require(usdtToken.transfer(recipient, amount), \"Transfer failed\");\n        emit Paid(recipient, amount, block.timestamp);\n    }\n\n    function _enforceDailyLimit(uint256 amount) internal {\n        if (block.timestamp > lastResetTimestamp + 1 days) {\n            dailySpent = 0;\n            lastResetTimestamp = block.timestamp;\n        }\n        require(dailySpent + amount <= DAILY_LIMIT, \"Daily payout limit exceeded\");\n        dailySpent += amount;\n    }\n\n    function getContractBalance() external view returns (uint256) {\n        return usdtToken.balanceOf(address(this));\n    }\n\n    function getRemainingDailyQuota() external view returns (uint256) {\n        if (block.timestamp > lastResetTimestamp + 1 days) {\n            return DAILY_LIMIT;\n        }\n        return DAILY_LIMIT - dailySpent;\n    }\n\n    function setMinPrice(uint256 newPrice) external onlyAdmin {\n        require(newPrice >= 1e18, \"Minimum must be >= 1 USDT\");\n        PRICE = newPrice;\n    }\n\n    function setDailyLimit(uint256 newLimit) external onlyAdmin {\n        require(newLimit > 0, \"Invalid limit\");\n        DAILY_LIMIT = newLimit;\n    }\n}\n\n\n\n\n// import \"./Multisig.sol\";\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// contract AffiliateVault is Multisig {\n//     address public SUPER_ADMIN;\n//     uint256 public PRICE = 1 * 1e18; // Minimum deposit: 1 USDT\n\n//     IERC20 public usdtToken;\n\n//     event Deposited(address indexed from, uint256 amount, uint256 timestamp);\n//     event Paid(address indexed to, uint256 amount, uint256 timestamp);\n//     event Withdrawn(address indexed to, uint256 amount, uint256 timestamp);\n\n//     constructor(\n//         address[] memory _owners,\n//         uint256 _numConfirmationsRequired,\n//         address _usdtTokenAddress\n//     ) Multisig(_owners, _numConfirmationsRequired) {\n//         SUPER_ADMIN = _owners[0];\n//         usdtToken = IERC20(_usdtTokenAddress);\n//     }\n\n//     modifier isSuperAdmin() {\n//         require(msg.sender == SUPER_ADMIN, \"Only Super Admin\");\n//         _;\n//     }\n\n//     /// @notice Depositor must approve() before calling this\n//     function deposit(uint256 amount) external {\n//         require(amount >= PRICE, \"Amount below minimum price\");\n//         require(usdtToken.allowance(msg.sender, address(this)) >= amount, \"Not approved\");\n//         require(usdtToken.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n\n//         emit Deposited(msg.sender, amount, block.timestamp);\n//     }\n\n//     function payUser(address recipient, uint256 amount) external isSuperAdmin {\n//         require(amount > 0, \"Amount must be greater than zero\");\n//         require(usdtToken.balanceOf(address(this)) >= amount, \"Insufficient balance\");\n\n//         require(usdtToken.transfer(recipient, amount), \"Transfer failed\");\n//         emit Paid(recipient, amount, block.timestamp);\n//     }\n\n    \n//     function withdraw(uint256 amount) external onlyAdmin {\n//         require(amount > 0, \"Amount must be greater than zero\");\n//         require(usdtToken.balanceOf(address(this)) >= amount, \"Insufficient balance\");\n\n//         require(usdtToken.transfer(msg.sender, amount), \"Withdraw failed\");\n//         emit Withdrawn(msg.sender, amount, block.timestamp);\n//     }\n\n//     function setMinPrice(uint256 newPrice) external onlyAdmin {\n//         require(newPrice >= 1e18, \"Price must be at least 1 USDT\");\n//         PRICE = newPrice;\n//     }\n\n//     function getContractBalance() external view returns (uint256) {\n//         return usdtToken.balanceOf(address(this));\n//     }\n\n//     function getPrice() external view returns (uint256) {\n//         return PRICE;\n//     }\n// }\n"
    },
    "contracts/FakeUSDT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract FakeUSDT is ERC20, Ownable {\n    // constructor(address initialOwner) ERC20(\"Fake USDT\", \"fUSDT\") Ownable(initialOwner) {}\n    constructor() ERC20(\"Fake USDT\", \"fUSDT\") {}\n\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n}\n"
    },
    "contracts/Lock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\n\ncontract Lock {\n    uint public unlockTime;\n    address payable public owner;\n\n    event Withdrawal(uint amount, uint when);\n\n    constructor(uint _unlockTime) payable {\n        require(\n            block.timestamp < _unlockTime,\n            \"Unlock time should be in the future\"\n        );\n\n        unlockTime = _unlockTime;\n        owner = payable(msg.sender);\n    }\n\n    function withdraw() public {\n        // Uncomment this line, and the import of \"hardhat/console.sol\", to print a log in your terminal\n        // console.log(\"Unlock time is %o and block timestamp is %o\", unlockTime, block.timestamp);\n\n        require(block.timestamp >= unlockTime, \"You can't withdraw yet\");\n        require(msg.sender == owner, \"You aren't the owner\");\n\n        emit Withdrawal(address(this).balance, block.timestamp);\n\n        owner.transfer(address(this).balance);\n    }\n}\n"
    },
    "contracts/Multisig.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Multisig\n * @dev Base multisig contract for shared approval logic\n */\ncontract Multisig {\n    address[] public owners;\n    mapping(address => bool) public isOwner;\n    uint public numConfirmationsRequired;\n\n    struct Transaction {\n        address to;\n        uint value;\n        bool executed;\n        uint numConfirmations;\n        uint timestamp;\n        string reason;\n    }\n\n    Transaction[] public transactions;\n    mapping(uint => mapping(address => bool)) public isConfirmed;\n\n    modifier onlyAdmin() {\n        require(isOwner[msg.sender], \"not owner\");\n        _;\n    }\n\n    modifier txExists(uint _txIndex) {\n        require(_txIndex < transactions.length, \"tx does not exist\");\n        _;\n    }\n\n    modifier notExecuted(uint _txIndex) {\n        require(!transactions[_txIndex].executed, \"tx already executed\");\n        _;\n    }\n\n    modifier notConfirmed(uint _txIndex) {\n        require(!isConfirmed[_txIndex][msg.sender], \"tx already confirmed\");\n        _;\n    }\n\n    event SubmitTransaction(address indexed owner, uint indexed txIndex, address indexed to, uint value, string reason);\n    event ConfirmTransaction(address indexed owner, uint indexed txIndex);\n    event RevokeConfirmation(address indexed owner, uint indexed txIndex);\n    event ExecuteTransaction(address indexed owner, uint indexed txIndex);\n\n    constructor(address[] memory _owners, uint _numConfirmationsRequired) {\n        require(_owners.length > 0, \"owners required\");\n        require(_numConfirmationsRequired > 0 && _numConfirmationsRequired <= _owners.length, \"invalid number of required confirmations\");\n\n        for (uint i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n            require(owner != address(0), \"invalid owner\");\n            require(!isOwner[owner], \"owner not unique\");\n            isOwner[owner] = true;\n            owners.push(owner);\n        }\n        numConfirmationsRequired = _numConfirmationsRequired;\n    }\n\n    function submitTransaction(address _to, uint _value, string memory _reason) public onlyAdmin {\n        uint txIndex = transactions.length;\n        transactions.push(Transaction({\n            to: _to,\n            value: _value,\n            executed: false,\n            numConfirmations: 0,\n            timestamp: block.timestamp,\n            reason: _reason\n        }));\n        emit SubmitTransaction(msg.sender, txIndex, _to, _value, _reason);\n    }\n\n    function confirmTransaction(uint _txIndex) public onlyAdmin txExists(_txIndex) notExecuted(_txIndex) notConfirmed(_txIndex) {\n        Transaction storage transaction = transactions[_txIndex];\n        transaction.numConfirmations += 1;\n        isConfirmed[_txIndex][msg.sender] = true;\n        emit ConfirmTransaction(msg.sender, _txIndex);\n    }\n\n    function executeTransaction(uint _txIndex) public onlyAdmin txExists(_txIndex) notExecuted(_txIndex) {\n        Transaction storage transaction = transactions[_txIndex];\n        require(transaction.numConfirmations >= numConfirmationsRequired, \"cannot execute tx\");\n        transaction.executed = true;\n        (bool success, ) = transaction.to.call{value: transaction.value}(\"\");\n        require(success, \"tx failed\");\n        emit ExecuteTransaction(msg.sender, _txIndex);\n    }\n\n    function revokeConfirmation(uint _txIndex) public onlyAdmin txExists(_txIndex) notExecuted(_txIndex) {\n        require(isConfirmed[_txIndex][msg.sender], \"tx not confirmed\");\n        Transaction storage transaction = transactions[_txIndex];\n        transaction.numConfirmations -= 1;\n        isConfirmed[_txIndex][msg.sender] = false;\n        emit RevokeConfirmation(msg.sender, _txIndex);\n    }\n\n    function getOwners() public view returns (address[] memory) {\n        return owners;\n    }\n\n    function getTransaction(uint _txIndex) public view returns (address, uint, bool, uint, uint, string memory) {\n        Transaction storage txData = transactions[_txIndex];\n        return (txData.to, txData.value, txData.executed, txData.numConfirmations, txData.timestamp, txData.reason);\n    }\n\n    function getTransactionCount() public view returns (uint) {\n        return transactions.length;\n    }\n}\n\n\n// contract Multisig {\n\n//     // Constructor\n//     constructor(address[] memory _owners, uint _numConfirmationsRequired) {\n//         require(_owners.length > 0, \"owners required\");\n//         require(\n//             _numConfirmationsRequired > 0 &&\n//                 _numConfirmationsRequired <= _owners.length,\n//             \"invalid number of required confirmations\"\n//         );\n\n//         for (uint i = 0; i < _owners.length; i++) {\n//             address owner = _owners[i];\n\n//             require(owner != address(0), \"invalid owner\");\n//             require(!isOwner[owner], \"owner not unique\");\n\n//             isOwner[owner] = true;\n//             owners.push(owner);\n//         }\n\n//         numConfirmationsRequired = _numConfirmationsRequired;\n        \n//     }\n\n\n//     event SubmitTransaction(\n//         address indexed owner,\n//         uint indexed txIndex,\n//         address indexed to,\n//         uint value\n//     );\n//     event ConfirmTransaction(address indexed owner, uint indexed txIndex);\n//     event RevokeConfirmation(address indexed owner, uint indexed txIndex);\n//     event ExecuteTransaction(address indexed owner, uint indexed txIndex);\n\n//     address[] public owners;\n//     mapping(address => bool) public isOwner;\n//     uint public numConfirmationsRequired;\n\n\n//     struct Transaction {\n//         address to;\n//         uint value;\n//         bool executed;\n//         uint numConfirmations;\n//     }\n\n//     // mapping from tx index => owner => bool\n//     mapping(uint => mapping(address => bool)) public isConfirmed;\n\n//     Transaction[] public transactions;\n\n//     modifier onlyAdmin() {\n//         require(isOwner[msg.sender], \"not owner\");\n//         _;\n//     }\n\n//     modifier txExists(uint _txIndex) {\n//         require(_txIndex < transactions.length, \"tx does not exist\");\n//         _;\n//     }\n\n//     modifier notExecuted(uint _txIndex) {\n//         require(!transactions[_txIndex].executed, \"tx already executed\");\n//         _;\n//     }\n\n//     modifier notConfirmed(uint _txIndex) {\n//         require(!isConfirmed[_txIndex][msg.sender], \"tx already confirmed\");\n//         _;\n//     }\n\n//     event Init(uint256, uint256);\n\n\n//     //1.Generar solicitud de retiro\n//     function submitTransaction(address _to,uint _value) public onlyAdmin {\n\n//         uint txIndex = transactions.length;\n\n//         uint256 totalAmount=address(this).balance;\n//         require(totalAmount>=_value,'incorrect value');\n\n//         transactions.push(\n//             Transaction({\n//                 to: _to,\n//                 value: _value,\n//                 executed: false,\n//                 numConfirmations: 0\n//             })\n//         );\n\n//         emit SubmitTransaction(msg.sender, txIndex, _to, _value);\n//     }\n\n\n//     // Los socios llaman a la funcion para dar permiso a retirar los fondos\n//     function confirmTransaction(uint _txIndex)public onlyAdmin\n//         txExists(_txIndex)\n//         notExecuted(_txIndex)\n//         notConfirmed(_txIndex){\n\n//         Transaction storage transaction = transactions[_txIndex];\n//         transaction.numConfirmations += 1;\n//         isConfirmed[_txIndex][msg.sender] = true;\n\n//         emit ConfirmTransaction(msg.sender, _txIndex);\n//     }\n\n//     // Si se tienen las confirmaciones necesarias, ejecutar transaccion\n//     function executeTransaction(uint _txIndex)\n//         public\n//         onlyAdmin\n//         txExists(_txIndex)\n//         notExecuted(_txIndex){\n\n//         Transaction storage transaction = transactions[_txIndex];\n\n//         require(\n//             transaction.numConfirmations >= numConfirmationsRequired,\n//             \"cannot execute tx\"\n//         );\n\n//         transaction.executed = true;\n        \n//         // Retiro del servidor los fondos\n//         (bool success, ) = transaction.to.call{value: transaction.value}(\"\");\n\n//         require(success, \"tx failed\");\n\n//         emit ExecuteTransaction(msg.sender, _txIndex);\n//     }\n\n//     // Socio retira su permiso de la transaccion\n//     function revokeConfirmation(uint _txIndex)\n//         public\n//         onlyAdmin\n//         txExists(_txIndex)\n//         notExecuted(_txIndex){\n//         Transaction storage transaction = transactions[_txIndex];\n\n//         require(isConfirmed[_txIndex][msg.sender], \"tx not confirmed\");\n\n//         transaction.numConfirmations -= 1;\n//         isConfirmed[_txIndex][msg.sender] = false;\n\n//         emit RevokeConfirmation(msg.sender, _txIndex);\n//     }\n\n//     // Returns owners of the contract \n//     function getOwners() public view returns (address[] memory) {\n//         return owners;\n//     }\n\n//     function getTransactionCount() public view returns (uint) {\n//         return transactions.length;\n//     }\n\n//     function getIsConfirmed(uint _txIndex) public view returns (bool) {\n//         return isConfirmed[_txIndex][msg.sender];\n//     }\n\n//     function getTransaction(uint _txIndex)public view\n//         returns (\n//             address to,\n//             uint value,\n//             bool executed,\n//             uint numConfirmations\n//         ){\n//         Transaction storage transaction = transactions[_txIndex];\n\n//         return (\n//             transaction.to,\n//             transaction.value,\n//             transaction.executed,\n//             transaction.numConfirmations\n//         );\n//     }\n\n// }"
    },
    "contracts/Signing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Signing{\n\n    \n    function verify(address _signer, string memory _message, bytes memory signature) public pure returns (bool) {\n        bytes32 messageHash = getMessageHash(_message);\n        bytes32 ethSignedMessage = getEthSignedMessageHash(messageHash);\n        address recoveredSigner = recoverSigner(ethSignedMessage, signature);\n        return recoveredSigner == _signer;\n    }\n\n    function getEthSignedMessageHash(bytes32 _messageHash) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash));\n    }\n\n    function getMessageHash(string memory _message) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_message));\n    }\n\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) public pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig) public pure returns (bytes32 r, bytes32 s, uint8 v) {\n        require(sig.length == 65, \"Invalid signature length\");\n\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        require(v == 27 || v == 28, \"Invalid signature value\");\n\n        return (r, s, v);\n    }\n}\n"
    },
    "contracts/VaultFactory.sol": {
      "content": "// import \"./AffiliateVault.sol\";\n\n// contract VaultFactory {\n//     address public server;\n//     address public arbiter;\n//     address public usdtToken;\n//     mapping(address => address) public affiliateVaults;\n//     address[] public allVaults;\n\n//     event VaultCreated(address indexed affiliate, address vault);\n\n//     constructor(address _server, address _arbiter, address _usdtToken) {\n//         server = _server;\n//         arbiter = _arbiter;\n//         usdtToken = _usdtToken;\n//     }\n\n//     function createVaultFor(address affiliate) external {\n//         require(msg.sender == server, \"Only server can deploy\");\n//         require(affiliateVaults[affiliate] == address(0), \"Vault already exists\");\n\n//         address[] memory owners = new address[](3);\n//         owners[0] = server;\n//         owners[1] = arbiter;\n//         owners[2] = affiliate;\n\n//         AffiliateVault vault = new AffiliateVault(owners, 2, usdtToken);\n\n//         affiliateVaults[affiliate] = address(vault);\n//         allVaults.push(address(vault));\n//         emit VaultCreated(affiliate, address(vault));\n//     }\n\n//     function getVault(address affiliate) external view returns (address) {\n//         return affiliateVaults[affiliate];\n//     }\n\n//     function getAllVaults() external view returns (address[] memory) {\n//         return allVaults;\n//     }\n// }\n// // // SPDX-License-Identifier: MIT\n// // pragma solidity ^0.8.0;\n\n// // import \"./AffiliateVault.sol\";\n\n// // contract VaultFactory {\n// //     address public server;\n// //     address public arbiter;\n// //     address public usdtToken;\n\n// //     mapping(address => address) public affiliateVaults;\n// //     address[] public allVaults;\n\n// //     event VaultCreated(address indexed affiliate, address vault);\n\n// //     constructor(address _server, address _arbiter, address _usdtToken) {\n// //         server = _server;\n// //         arbiter = _arbiter;\n// //         usdtToken = _usdtToken;\n// //     }\n\n// //     function createVault() external {\n// //         require(affiliateVaults[msg.sender] == address(0), \"Vault already exists\");\n\n// //         address [] memory owners = new address[](3);\n// //         owners[0] = server; \n// //         owners[1] = arbiter;\n// //         owners[2] = msg.sender; // affiliate (caller)\n\n// //         AffiliateVault vault = new AffiliateVault(\n// //             owners,\n// //             2, // multisig: 2 out of 3\n// //             usdtToken\n// //         );\n\n// //         affiliateVaults[msg.sender] = address(vault);\n// //         allVaults.push(address(vault));\n\n// //         emit VaultCreated(msg.sender, address(vault));\n// //     }\n\n// //     function getVault(address affiliate) external view returns (address) {\n// //         return affiliateVaults[affiliate];\n// //     }\n\n// //     function getAllVaults() external view returns (address[] memory) {\n// //         return allVaults;\n// //     }\n// // }\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}